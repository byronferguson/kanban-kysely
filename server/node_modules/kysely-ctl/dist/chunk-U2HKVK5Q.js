// node_modules/.pnpm/tsup@8.2.1_jiti@1.21.6_postcss@8.4.39_tsx@4.16.2_typescript@5.5.3_yaml@2.4.5/node_modules/tsup/assets/esm_shims.js
import { fileURLToPath } from "node:url";
import path from "node:path";
var getFilename = () => fileURLToPath(import.meta.url);
var getDirname = () => path.dirname(getFilename());
var __dirname = /* @__PURE__ */ getDirname();
var __filename = /* @__PURE__ */ getFilename();

// src/config/get-file-prefix.mts
function getKnexTimestampPrefix() {
  const now = /* @__PURE__ */ new Date();
  const year = now.getUTCFullYear().toString();
  const month = toPaddedNumber(now.getUTCMonth() + 1);
  const day = toPaddedNumber(now.getUTCDate());
  const hour = toPaddedNumber(now.getUTCHours());
  const minute = toPaddedNumber(now.getUTCMinutes());
  const second = toPaddedNumber(now.getUTCSeconds());
  return `${year}${month}${day}${hour}${minute}${second}_`;
}
function toPaddedNumber(number) {
  return number.toString().padStart(2, "0");
}
function getMillisPrefix() {
  return `${Date.now()}_`;
}

// src/kysely/ts-file-migration-provider.mts
import { consola } from "consola";
import { join } from "pathe";
import { filename } from "pathe/utils";

// src/utils/get-file-type.mts
function getFileType(path2) {
  let extension = "";
  const lastIndex = path2.length - 1;
  let i = 0;
  for (; i < 3; i++) {
    const char = path2.charAt(lastIndex - i);
    if (char === ".") {
      break;
    }
    extension = `${char}${extension}`;
  }
  if (extension.length < 2 || path2.charAt(lastIndex - i) !== "." || path2.charAt(lastIndex - (i + 1)) === "d" && path2.charAt(lastIndex - (i + 2)) === ".") {
    return "IRRELEVANT";
  }
  if (["ts", "mts", "cts"].includes(extension)) {
    return "TS";
  }
  if (["js", "mjs", "cjs"].includes(extension)) {
    return "JS";
  }
  return "IRRELEVANT";
}

// src/utils/import-ts-file.mts
import { isWindows, runtime } from "std-env";

// src/utils/pkg-json.mts
import { readPackageJSON } from "pkg-types";

// src/config/get-cwd.mts
import { resolve } from "pathe";
import { isDeno, process } from "std-env";
var ACTUAL_CWD = process.cwd?.() || (isDeno ? globalThis.Deno.cwd() : "");
var cwd;
function getCWD(args) {
  return cwd ||= args?.cwd ? resolve(ACTUAL_CWD, args.cwd) : ACTUAL_CWD;
}

// src/utils/pkg-json.mts
var PACKAGE_JSONS = {};
async function getConsumerPackageJSON(args) {
  return await getPackageJSON({ startingFrom: getCWD(args) });
}
async function getCTLPackageJSON() {
  return await getPackageJSON({ id: "kysely-ctl" });
}
async function getPackageJSON(options) {
  const { id, startingFrom = __dirname } = options;
  return PACKAGE_JSONS[`${String(id)}_${startingFrom}`] ||= await readPackageJSON(id, { startingFrom });
}

// src/utils/import-ts-file.mts
async function importTSFile(path2) {
  if (runtime !== "node") {
    return await import(path2);
  }
  const pkgJSON = await getConsumerPackageJSON();
  if (pkgJSON.type === "module") {
    const { tsImport } = await import("tsx/esm/api");
    if (isWindows && !path2.startsWith("file://")) {
      path2 = `file://${path2}`;
    }
    return await tsImport(path2, { parentURL: import.meta.url });
  }
  const { require: tsRequire } = await import("tsx/cjs/api");
  return await tsRequire(path2, __filename);
}

// src/utils/safe-readdir.mts
import { mkdir, readdir } from "node:fs/promises";
async function safeReaddir(path2) {
  try {
    return await readdir(path2);
  } catch (err) {
    await mkdir(path2);
    return await readdir(path2);
  }
}

// src/kysely/ts-file-migration-provider.mts
var TSFileMigrationProvider = class {
  #props;
  constructor(props) {
    this.#props = props;
  }
  async getMigrations() {
    const migrations = {};
    const files = await safeReaddir(this.#props.migrationFolder);
    for (const fileName of files) {
      const fileType = getFileType(fileName);
      const isTS = fileType === "TS";
      if (!isTS) {
        if (!this.#props.allowJS) {
          consola.warn(`Ignoring \`${fileName}\` - not a TS file.`);
          continue;
        }
        if (fileType !== "JS") {
          consola.warn(`Ignoring \`${fileName}\` - not a TS/JS file.`);
          continue;
        }
      }
      const filePath = join(this.#props.migrationFolder, fileName);
      const migration = await (isTS ? importTSFile(filePath) : import(filePath));
      const migrationKey = filename(fileName);
      if (isMigration(migration?.default)) {
        migrations[migrationKey] = migration.default;
      } else if (isMigration(migration)) {
        migrations[migrationKey] = migration;
      } else {
        consola.warn(`Ignoring \`${fileName}\` - not a migration.`);
      }
    }
    return migrations;
  }
};
function isMigration(obj) {
  return typeof obj === "object" && obj !== null && !Array.isArray(obj) && "up" in obj && typeof obj.up === "function";
}

// src/seeds/file-seed-provider.mts
import { consola as consola2 } from "consola";
import { join as join2 } from "pathe";
import { filename as filename2 } from "pathe/utils";
var FileSeedProvider = class {
  #props;
  constructor(props) {
    this.#props = props;
  }
  async getSeeds(seedNames) {
    const seeds = {};
    let files = await safeReaddir(this.#props.seedFolder);
    if (seedNames) {
      const seedNameArray = Array.isArray(seedNames) ? seedNames : [seedNames];
      if (seedNameArray.length) {
        files = files.filter(
          (fileName) => seedNameArray.includes(filename2(fileName))
        );
      }
    }
    for (const fileName of files) {
      const fileType = getFileType(fileName);
      const isTS = fileType === "TS";
      if (!isTS) {
        if (!this.#props.allowJS) {
          consola2.warn(`Ignoring \`${fileName}\` - not a TS file.`);
          continue;
        }
        if (fileType !== "JS") {
          consola2.warn(`Ignoring \`${fileName}\` - not a TS/JS file.`);
          continue;
        }
      }
      const filePath = join2(this.#props.seedFolder, fileName);
      const seed = await (isTS ? importTSFile(filePath) : import(filePath));
      const seedKey = filename2(fileName);
      if (isSeed(seed?.default)) {
        seeds[seedKey] = seed.default;
      } else if (isSeed(seed)) {
        seeds[seedKey] = seed;
      } else {
        consola2.warn(`Ignoring \`${fileName}\` - not a seed.`);
      }
    }
    return seeds;
  }
};
function isSeed(obj) {
  return typeof obj === "object" && obj !== null && !Array.isArray(obj) && "seed" in obj && typeof obj.seed === "function";
}

// src/seeds/seeder.mts
var Seeder = class {
  #props;
  constructor(props) {
    this.#props = props;
  }
  async getSeeds(seedNames) {
    const seeds = await this.#props.provider.getSeeds(seedNames);
    return Object.entries(seeds).map(([name, seed]) => ({
      name,
      seed
    }));
  }
  async run(seedNames) {
    const seeds = await this.getSeeds(seedNames);
    const resultSet = {
      error: void 0,
      results: seeds.map(
        (seed) => ({
          seedName: seed.name,
          status: "NotExecuted"
        })
      )
    };
    for (let i = 0, len = seeds.length; i < len && !resultSet.error; ++i) {
      try {
        await seeds[i].seed.seed(this.#props.db);
        resultSet.results[i].status = "Success";
      } catch (err) {
        resultSet.results[i].status = "Error";
        resultSet.error = err;
      }
    }
    return resultSet;
  }
};

export {
  __dirname,
  __filename,
  getCWD,
  getConsumerPackageJSON,
  getCTLPackageJSON,
  getKnexTimestampPrefix,
  getMillisPrefix,
  TSFileMigrationProvider,
  FileSeedProvider,
  Seeder
};
