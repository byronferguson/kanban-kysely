"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.mts
var src_exports = {};
__export(src_exports, {
  FileSeedProvider: () => FileSeedProvider,
  Seeder: () => Seeder,
  TSFileMigrationProvider: () => TSFileMigrationProvider,
  defineConfig: () => defineConfig,
  getKnexTimestampPrefix: () => getKnexTimestampPrefix
});
module.exports = __toCommonJS(src_exports);

// node_modules/.pnpm/tsup@8.2.1_jiti@1.21.6_postcss@8.4.39_tsx@4.16.2_typescript@5.5.3_yaml@2.4.5/node_modules/tsup/assets/cjs_shims.js
var getImportMetaUrl = () => typeof document === "undefined" ? new URL(`file:${__filename}`).href : document.currentScript && document.currentScript.src || new URL("main.js", document.baseURI).href;
var importMetaUrl = /* @__PURE__ */ getImportMetaUrl();

// src/config/define-config.mts
var defineConfig = (input) => input;

// src/kysely/ts-file-migration-provider.mts
var import_consola = require("consola");
var import_pathe2 = require("pathe");
var import_utils = require("pathe/utils");

// src/utils/get-file-type.mts
function getFileType(path) {
  let extension = "";
  const lastIndex = path.length - 1;
  let i = 0;
  for (; i < 3; i++) {
    const char = path.charAt(lastIndex - i);
    if (char === ".") {
      break;
    }
    extension = `${char}${extension}`;
  }
  if (extension.length < 2 || path.charAt(lastIndex - i) !== "." || path.charAt(lastIndex - (i + 1)) === "d" && path.charAt(lastIndex - (i + 2)) === ".") {
    return "IRRELEVANT";
  }
  if (["ts", "mts", "cts"].includes(extension)) {
    return "TS";
  }
  if (["js", "mjs", "cjs"].includes(extension)) {
    return "JS";
  }
  return "IRRELEVANT";
}

// src/utils/import-ts-file.mts
var import_std_env2 = require("std-env");

// src/utils/pkg-json.mts
var import_pkg_types = require("pkg-types");

// src/config/get-cwd.mts
var import_pathe = require("pathe");
var import_std_env = require("std-env");
var ACTUAL_CWD = import_std_env.process.cwd?.() || (import_std_env.isDeno ? globalThis.Deno.cwd() : "");
var cwd;
function getCWD(args) {
  return cwd ||= args?.cwd ? (0, import_pathe.resolve)(ACTUAL_CWD, args.cwd) : ACTUAL_CWD;
}

// src/utils/pkg-json.mts
var PACKAGE_JSONS = {};
async function getConsumerPackageJSON(args) {
  return await getPackageJSON({ startingFrom: getCWD(args) });
}
async function getPackageJSON(options) {
  const { id, startingFrom = __dirname } = options;
  return PACKAGE_JSONS[`${String(id)}_${startingFrom}`] ||= await (0, import_pkg_types.readPackageJSON)(id, { startingFrom });
}

// src/utils/import-ts-file.mts
async function importTSFile(path) {
  if (import_std_env2.runtime !== "node") {
    return await import(path);
  }
  const pkgJSON = await getConsumerPackageJSON();
  if (pkgJSON.type === "module") {
    const { tsImport } = await import("tsx/esm/api");
    if (import_std_env2.isWindows && !path.startsWith("file://")) {
      path = `file://${path}`;
    }
    return await tsImport(path, { parentURL: importMetaUrl });
  }
  const { require: tsRequire } = await import("tsx/cjs/api");
  return await tsRequire(path, __filename);
}

// src/utils/safe-readdir.mts
var import_promises = require("fs/promises");
async function safeReaddir(path) {
  try {
    return await (0, import_promises.readdir)(path);
  } catch (err) {
    await (0, import_promises.mkdir)(path);
    return await (0, import_promises.readdir)(path);
  }
}

// src/kysely/ts-file-migration-provider.mts
var TSFileMigrationProvider = class {
  #props;
  constructor(props) {
    this.#props = props;
  }
  async getMigrations() {
    const migrations = {};
    const files = await safeReaddir(this.#props.migrationFolder);
    for (const fileName of files) {
      const fileType = getFileType(fileName);
      const isTS = fileType === "TS";
      if (!isTS) {
        if (!this.#props.allowJS) {
          import_consola.consola.warn(`Ignoring \`${fileName}\` - not a TS file.`);
          continue;
        }
        if (fileType !== "JS") {
          import_consola.consola.warn(`Ignoring \`${fileName}\` - not a TS/JS file.`);
          continue;
        }
      }
      const filePath = (0, import_pathe2.join)(this.#props.migrationFolder, fileName);
      const migration = await (isTS ? importTSFile(filePath) : import(filePath));
      const migrationKey = (0, import_utils.filename)(fileName);
      if (isMigration(migration?.default)) {
        migrations[migrationKey] = migration.default;
      } else if (isMigration(migration)) {
        migrations[migrationKey] = migration;
      } else {
        import_consola.consola.warn(`Ignoring \`${fileName}\` - not a migration.`);
      }
    }
    return migrations;
  }
};
function isMigration(obj) {
  return typeof obj === "object" && obj !== null && !Array.isArray(obj) && "up" in obj && typeof obj.up === "function";
}

// src/seeds/file-seed-provider.mts
var import_consola2 = require("consola");
var import_pathe3 = require("pathe");
var import_utils2 = require("pathe/utils");
var FileSeedProvider = class {
  #props;
  constructor(props) {
    this.#props = props;
  }
  async getSeeds(seedNames) {
    const seeds = {};
    let files = await safeReaddir(this.#props.seedFolder);
    if (seedNames) {
      const seedNameArray = Array.isArray(seedNames) ? seedNames : [seedNames];
      if (seedNameArray.length) {
        files = files.filter(
          (fileName) => seedNameArray.includes((0, import_utils2.filename)(fileName))
        );
      }
    }
    for (const fileName of files) {
      const fileType = getFileType(fileName);
      const isTS = fileType === "TS";
      if (!isTS) {
        if (!this.#props.allowJS) {
          import_consola2.consola.warn(`Ignoring \`${fileName}\` - not a TS file.`);
          continue;
        }
        if (fileType !== "JS") {
          import_consola2.consola.warn(`Ignoring \`${fileName}\` - not a TS/JS file.`);
          continue;
        }
      }
      const filePath = (0, import_pathe3.join)(this.#props.seedFolder, fileName);
      const seed = await (isTS ? importTSFile(filePath) : import(filePath));
      const seedKey = (0, import_utils2.filename)(fileName);
      if (isSeed(seed?.default)) {
        seeds[seedKey] = seed.default;
      } else if (isSeed(seed)) {
        seeds[seedKey] = seed;
      } else {
        import_consola2.consola.warn(`Ignoring \`${fileName}\` - not a seed.`);
      }
    }
    return seeds;
  }
};
function isSeed(obj) {
  return typeof obj === "object" && obj !== null && !Array.isArray(obj) && "seed" in obj && typeof obj.seed === "function";
}

// src/seeds/seeder.mts
var Seeder = class {
  #props;
  constructor(props) {
    this.#props = props;
  }
  async getSeeds(seedNames) {
    const seeds = await this.#props.provider.getSeeds(seedNames);
    return Object.entries(seeds).map(([name, seed]) => ({
      name,
      seed
    }));
  }
  async run(seedNames) {
    const seeds = await this.getSeeds(seedNames);
    const resultSet = {
      error: void 0,
      results: seeds.map(
        (seed) => ({
          seedName: seed.name,
          status: "NotExecuted"
        })
      )
    };
    for (let i = 0, len = seeds.length; i < len && !resultSet.error; ++i) {
      try {
        await seeds[i].seed.seed(this.#props.db);
        resultSet.results[i].status = "Success";
      } catch (err) {
        resultSet.results[i].status = "Error";
        resultSet.error = err;
      }
    }
    return resultSet;
  }
};

// src/config/get-file-prefix.mts
function getKnexTimestampPrefix() {
  const now = /* @__PURE__ */ new Date();
  const year = now.getUTCFullYear().toString();
  const month = toPaddedNumber(now.getUTCMonth() + 1);
  const day = toPaddedNumber(now.getUTCDate());
  const hour = toPaddedNumber(now.getUTCHours());
  const minute = toPaddedNumber(now.getUTCMinutes());
  const second = toPaddedNumber(now.getUTCSeconds());
  return `${year}${month}${day}${hour}${minute}${second}_`;
}
function toPaddedNumber(number) {
  return number.toString().padStart(2, "0");
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  FileSeedProvider,
  Seeder,
  TSFileMigrationProvider,
  defineConfig,
  getKnexTimestampPrefix
});
